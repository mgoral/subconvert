Subconvert - movie subtitles converter.
====================

Table of contents:
0 Capabilities
1 User manual
    1.1 Installation
        1.1.1 Uninstalling
        1.1.2 Reinstalling
        1.1.3 Dependencies
    1.2 Usage
        1.2.1 Available options
        1.2.2 Available formats
2 Programmer manual
3 License

====================

[ 0 Capabilities ]
    * fast and lightweight
    * easy to use: at minimum select subtitle file and you're done.
    * available as a window (GUI) and terminal (CLI) application
    * supports multiple subtitle formats
    * automatically checks video files for FPS information
    * converts between frame and time formats
    * supports as many file encodings as Python standard library does
    * detects encodings automatically
    * translatable (via gettext)

[ 1 User manual ]
This section describes installation and usage of subconvert.

[ 1.1 Installation ]
Since a version 0.8.3, a new Linux installer has been added. It is located in
the the main Subconvert directory and you can run it as follows:
    $ ./install.sh install

The installer will then ask you about install path. It should be a directory
where 'bin', 'share', 'share/doc' and 'share/locale' subdirectories reside.
Usually it will be simply '/usr' directory (you can choose it by pressing enter
on your keyboard on that step of installation), but you can also choose another
directory, like your home. Subconvert will work fine as long as
'chosen_path/bin' will be in your $PATH. It may not be visible on your system
menu though because most desktop environments search for application information
in /usr/share/applications.

You can specify install directory in script invocation (note the second
argument in a command below):
    $ ./install.sh install user/specified/path

Remember that if you want to install Subconvert outside of your HOME directory,
you'll need root privileges.

[ 1.1.2 Uninstalling ]
Install script allows you to remove Subconvert the same way, with optional path
argument:
    $ ./install.sh uninstall [user/specified/path]

At the moment the script will REQUIRE specifying earlier or later install path
(or -- being more specific -- PREFIX). This might change in next releases. If
you don't remember where Subconvert is installed, you can test it with common
Unix command, 'which':
    $ which subconvert

This will point you to a symbolic link in a ${PREFIX}/bin. ${PREFIX} is a
directory that you're looking for.

[ 1.1.3 Reinstalling ]
Reinstalling is very similar to installing and reinstalling. In fact, install
script simply executes those two actions one after another:
    $ ./install.sh reinstall [user/specified/path]

[ 1.1.4 Dependencies ]
    + Python 2.6+
    + python-qt4
    + python-chardet (optional, recommended)
    + MPlayer (optional, recommended)

[ 1.2 Usage ]
    subconvert [options] input_file [input_file...]

You can specify as many input files as you like to begin batch converting them.
You can also use common Unix wildcards:
    subconvert [options] *
    subconvert [options] *.txt
    subconvert [options] common_prefix*.srt
    subconvert [options] subtitle.s{rt,ub}

[ 1.2.1 Available options ]
Usage: subconvert.py [options] input_file [input_file...]

Options:

  General options:

    --version
        Show program's version number and exit.

    -h, --help
        Show this help message and exit.

    -f, --force
        Force all operations without asking (assuming yes).

    -q, --quiet
        Silence Subconvert output.

    --debug
        Generate debug output.

  File options:
    Options that describe how subtitle files should be handled.

    -e ENCODING, --encoding=ENCODING
        Input file encoding. If no encoding is provided, Subconvert will try to
        automatically detect file encoding and switches to 'UTF-8' when
        unsuccessfull. For a list of available encodings, see:
        http://docs.python.org/library/codecs.html#standard-encodings.

    --output-encoding=OUTPUT_ENCODING
        Output file encoding. If no output encoding is provided, subconvert
        will save output files with the same encoding as input.

    -t FORMAT_, --format=FORMAT_
        Output subtitle format. Default: subrip. See [ 1.2.2 Available formats ]
        for a list of available formats

    -x EXT, --extension=EXT
        Specify extension of the output file if the default one is not what you
        like.

  Movie options:
    Options that describe the corelations between subtitle and movie files.

    --fps=FPS
        Movie/subtitles frames per second. Default: 25.

    -A, --auto-fps
        Automatically try to get fps from MPlayer.

    -v MOVIE_FILE, --video=MOVIE_FILE
        Movie file to get FPS info from.

EXAMPLES:
    subconvert subtitles.txt
        Create subtitles.srt, UTF-8 encoded (subrip wit srt extension is default
        format and UTF-8 is encoding fallback)
    subconvert *.txt
        Convert all txt files in a directory
    subconvert -e cp1250 subtitles.txt
        Convert subtitles.txt to subrip. Leave original file encoding which is
        explicitly set to cp1250.
    subconvert -t microdvd --fps=23.976 subtitles.srt
        Create subtitles.sub microdvd format. Conversion rate from time format
        (subrip) to frame format (microdvd) is 23.976 FPS.

[ 1.2.2 Available formats ]
    -t FORMAT and --format=FORMAT options indicate the subtitle format that
    output should be written to. Currently available subtitle formats are:

    * microdvd
    * subrip
    * tmp
    * subviewer
    * mpl2

[ 2 Programmer manual ]
The main application uses GenericSubParser class and its subclasses which are
automatically loaded. Each of those subclasses should overwrite some attributes
and methods which are called from the GenericSubParser.parse() method (that one
MUST NOT be overwritten as it's the heart and the brain of the application).
This method works as a generator and parsing results are yielded for each
subtitle section. Parsing results are given as a dictionary:
    { sub_no, sub_fmt*, sub: { time_from**, time_to**, text } }
    * 'time' or 'frame'
    ** FrameTime format

You should overwrite the following constants:

__SUB_TYPE__
    Name of subtitle format.

__OPT__
    String which represents a format name that a user can select (-t and
    --format options). For example, if user writes subconvert -t your_opt, then
    a subclass with __OPT__ == 'your_opt' will be chosen to handle subtitle
    converting and formatting.

__EXT__
    Extension of the output file used if user haven't specified it through the
    options.

__FMT__
    Specify subtitle type (either 'frame' or 'time'). You don't have to
    overwrite it -- if it's not specified, parser will try to determine it
    automatically. Keep in mind though that it's only a simple regex and doesn't
    have to be accurate every time, so it's better to write it explicitly.

__WITH_HEADER__
    Set to True if subtitle format contains some kind of header.

__MAX_HEADER_LEN__
    Performance option. Maximum line number to which parser will check for
    header. By default it is set to 50 but you can change it if you want.

end_pattern
    This pattern is searched in every line of input file. When it's matched, it
    means that a single subtitle has been found. Further searches (described
    below) are going to be made on that subtitle and if they are successfull, a
    parsing result is yielded and sub_section string is cleared.
    For example, for a subrip file it might be a double endline. Only when we
    found a single subtitle section, we're able to get from it time, formatting,
    etc.

pattern
    Regex pattern that operates on a found subtitle section. It should match
    groups named <text>, <time_from> and possibly <time_to>, where <text> is a
    subtitle text and <time_from> and <time_to> are subtitle timestamps or
    frames (depending on subtitle format).

sub_fmt
    Subtitle format string. It indicates how a subtitle block should look like.
    It contains of tags that are understandable to Subconvert. This format
    string is used place a specific part of parsed subtitle into a correct place
    in new one.
    Allowed tags: {gsp_no}, {gsp_from}, {gsp_to}, {gsp_text}

sub_formatting
    A dictionary containing subtitle text formatting tags. Those tags indicate
    formatting which some subtitle formats allow (or, telling the truth, some
    movie players allow, e.g. not all players support subrip text formatting).
    There are both opening and closing tags to indicate formatted parts of text.
    When a subtitle is converted to the specific format, those tags are changed
    to the correct formatting for that format according to the specifications
    included in sub_formatting dictionary.
    Allowed tags: {gsp_x_} for opening tags and {_gsp_x} for closing tags,
    where x is one of the following: b, i, u (for bold, italics and underline)
    Also, {gsp_nl} is allowed to indicate line breaks.
    Example: sub_formatting = {'gsp_nl': r'|',}

There are also a couple of methods that usually should be overwritten:

def __init__(self, filename, fps, encoding, lines=None)
    Don't forget to call GenericSubParser.__init__(args) from your subclass
    constructor.

def get_header(self, section, atom)
    Called during parsing when input format contains header (__WITH_HEADER__ is
    set to True). This function should try to find and parse header in a given
    sub_section and save the results as a dictionary to atom['header']. If
    parsing was successfull it should return True and False otherwise. Note that
    though programmer is not required to follow any naming convention, it is
    HIGHLY RECOMMENDED to name atom['header'] keys with full, lower case,
    underscore separated names (like 'information', 'delay', 'author',
    'version', 'title' etc.). It is to allow sharing those pieces of
    informations between various formats.
    For formats with __WITH_HEADER__ set to True this method is checked until it
    returns True (or __MAX_HEADER_LEN__ is reached). After that it is not called
    again

def convert_header(self, header)
    Converts a given header (which is dictionary saved by get_header method) to
    a string that can be saved to a file. It is HIGHLY RECOMMENDED to define
    default values for all required pieces of informations as subtitle formats
    do not have to share the same informations between each other.

def format_text(self, string)
    Converts string formatting in a given string from a subtitle-format specific
    to the one recognised by GenericSubParser.  Specific subtitle formatting
    should be changed with tags described in sub_formatting constant. It
    can be done any way you prefer (regex, string manipulation, ...).
    Important note: don't forget to escape any curly braces ('{' and '}') that
    may occur in subtitle text as they might break things down.

def str_to_frametime(self, string)
    Converts strings which are recognised as a timestamp to FrameTime objects.
    It is important to have a common time format which can be passed, recognised
    and operated on by various GenericSubParser subclasses (subtitle formats).

def get_time(self, ft, which)
    Opposite operation to 'str_to_frametime'. Extracts time (time_from and
    time_to) from a given FrameTime object to properly formatted string which
    represents a time format specific for an output subtitle format. There is
    also a possibility to specify different formats for 'time_from' and
    'time_to' thanks to 'which' argument.

Please note that if you feel ok with defaults of all above constants attributes,
you don't have to even touch them. Read the code for more info!

[ 3 License ]
Subconvert is free software licensed under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
For details, see <LICENSE.txt> or http://www.gnu.org/licenses/gpl.html
