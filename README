SUBCONVERT - a simple Python application which converts various subtitle
formats to each others.

====================

Table of contents:
0 Capabilities
1 User manual
    1.1 Installation
        1.1.1 Uninstalling
        1.1.2 Reinstalling
        1.1.3 Dependencies
    1.2 Usage
        1.2.1 Available options
        1.2.2 Available formats
2 Programmer manual
3 License

====================

[ 0 Capabilities ]
    * easy to use: at minimum select sub file and you're done.
    * fast and lightweight
    * supports multiple sub formats (more to come)
    * converts betweeen frame and time formats
    * supports automatically getting sub fps from avi file
    * supports many file encodings (from ascii through "iso's" to utf16)
    * detects encodings automatically
    * ready to translate using gettext utilities

[ 1 User manual ]
This section describes installation and usage of subconvert.

[ 1.1 Installation ]
Since 0.8.3, a new Linux installer has been added. It is located in the main
SubConvert directory and you can run it as follows:
    $ ./install.sh install

The installer will then ask you about install path. It should be a directory
where 'bin', 'share', 'share/doc' and 'share/locale' subdirectories reside.
Usually it will be simply '/usr' directory (you can choose it by pressing enter
on your keyboard on that step of installation), but you can also choose another
directory, like your home. SubConvert will work fine as long as
'chosen_path/bin' will be in your $PATH.

You can specify install directory in script invocation (note the second
argument in a command below):
    $ ./install.sh install user/specified/path

Remember that if you want to install SubConvert outside your Home directory,
you'd need root privileges.

[ 1.1.2 Uninstalling ]
Install script allows you to remove SubConvert the very same way, with optional
path argument:
    $ ./install.sh uninstall [user/specified/path]

At the moment the script will REQUIRE specifying earlier or later install path
(or -- being more specific -- PREFIX). This is a feature that might change 
in next releases. If you don't remember where SubConver is installed, you can
test it with common Unix command, 'which':
    $ which subconvert

It will show you path to symbolic links placed in bin directory, but together with 
knowledge of things contained in this chapter it should give you a hint about
SubConvert installation path.

[ 1.1.3 Reinstalling ]
Reinstalling is very similar to installing and reinstalling. In fact, install
script simply executes those two actions one after the other:
    $ ./install.sh reinstall [user/specified/path]

[ 1.1.4 Dependencies ]
    + Python 2.6+
    + python-qt4
    + python-chardet (optional, recommended)
    + MPlayer (optional, recommended)

[ 1.2 Usage ]
Subconvert has plenty available options:
    subconvert [options] input_file [input_file...]

You can specify as many input files as you like to begin batch converting them.
You can also ask subconvert to convert all files like this:
    subconvert [options] *
    subconvert [options] *.txt
    subconvert [options] common_prefix*.srt

[ 1.2.1 Available options ]
Usage: subconvert.py [options] input_file [input_file...]

Options:

  General options:

    --version
        Show program's version number and exit.

    -h, --help
        Show this help message and exit.

    -f, --force
        Force all operations without asking (assuming yes).

    -q, --quiet
        Silence SubConvert output.

    --debug
        Generate debug output.

  File options:
    Options that describe how subtitle files should be handled.

    -e ENCODING, --encoding=ENCODING
        Input file encoding. If no encoding is provided,SubConvert will try to
        automatically detect file encoding and switch to 'UTF-8' When
        unsuccessfull. For a list of available encodings, see:
        http://docs.python.org/library/codecs.html#standard-encodings.

    --output-encoding=OUTPUT_ENCODING
        Output file encoding. If no output encoding is provided, subconvert
        will save output files with the same encoding as input.

    -t FORMAT_, --format=FORMAT_
        Output subtitle format. Default: subrip.

    -x EXT, --extension=EXT
        Specify extension of the output file if the default one is not what you
        like.

  Movie options:
    Options that describe the corelations between subtitle and movie files.

    --fps=FPS
        Movie/subtitles frames per second. Default: 25.

    -A, --auto-fps
        Automatically try to get fps from MPlayer.

    -v MOVIE_FILE, --video=MOVIE_FILE
        Movie file to get FPS info from.

EXAMPLES:
    subconvert subtitles.txt
        Create subtitles.srt encoded in ascii (subrip wit srt extension is
        default format)
    subconvert *.txt
        Convert all txt files in a directory
    subconvert -e cp1250 subtitles.txt
        Create subtitles.srt encoded in cp1250 (windows-1250) from subtitles.txt
        which is encoded in cp1250.
    subconvert -t microdvd --fps=23.976 subtitles.srt
        Create subtitles.sub microdvd format, encoded in asci with frames
        converter from time format at 23.976 fps ratio

[ 1.2.2 Available formats ]
    -t FORMAT and --format=FORMAT options indicate the subtitle format that
    output should be written to. Currently available sub formats are:
    
    * microdvd
    * subrip
    * tmp
    * subviewer
    * mpl2

[ 2 Programmer manual ]
Generally main program uses GenericSubParser class and it subclasses which are
automatically loaded. Each of thos subclasses should overwrite some attributes
and methods which are called from the GenericSubParser.parse() method (that one
MUST NOT be overwritten as it's the heart and the brain of the application).
This method works as a generator and parsing results are yielded for each
subtitle section. Parsing results are served as a dictionary:
    { sub_no, sub_fmt*, sub: { time_from**, time_to**, text } }
    * 'time' or 'frame'
    ** FrameTime format

You should overwrite the following constants:

__SUB_TYPE__
    Name of sub format.

__OPT__
    String which equals format option that a user can select (-t and --format
    options). For example, if user writes subconvert -t your_opt, than a
    subclass with __OPT__ == 'your_opt' will be chosen to handle sub converting
    and formatting.

__EXT__
    Extension of the output file used if user haven't specified output file.

__FMT__
    Specify sub type (either 'frame' or 'time'). You don't have to overwrite it
    -- if it's not specified, parser will try to determine it automatically.
    Keep in mind though that it's only a simple regex and doesn't have to be
    accurate every time, so it's better to specify it explicitly.

__WITH_HEADER__
    Set to True if subtitle format contains some kind of header.

__MAX_HEADER_LEN__
    Performance option. Maximum line number to which subconvert will check for
    header. By default it is set to 50 but you can (though you do not have to)
    override it if you want.

end_pattern
    This pattern is searched in every line of imput file. When it's matched, it
    means that subtitle section has been found and on that section are going to
    be made forther searches (described below). When those searches are
    successfull, parsing result is yielded and sub_section string is cleared.

pattern
    Regex pattern that should catch subtitle section text. It should catch
    groups named <text>, <time_from> and possibly <time_to>, where <text> is a
    subtitle text and <time_from> and <time_to> are subtitle timestamps or
    frames (depending on sub format).

sub_fmt
    Subtitle format string. It indicates how a subtitle block should look like.
    Each of the allowed tags will be replaced by a specific sub part.
    Allowed tags: {gsp_no}, {gsp_from}, {gsp_to}, {gsp_text}

sub_formatting
    A dictionary containing subtitle text formatting tags. Those tags indicate
    formatting which some sub formats allow (or, telling the truth, some movie
    players allow as for example not all players support subrip text formatting).
    There are both opening and closing tags to indicate formatted parts of text.
    When a subtitle is converted to the specific format, those tags are changed
    to the correct formatting indicators for that subtitle format according to
    the specifications included in sub_formatting dictionary.
    Allowed tags: {gsp_x*_} for opening tags and {_gsp_x} for closing tags,
    where x is one of the following: b, i, u (for bold, italics and underline)
    Also, {gsp_nl} is allowed to indicate line breaks.

There is also a set of methods that probably should be overwritten to complete
the format class:

def __init__(self, file, encoding)
    Don't forget to call GenericSubParser.__init__(...) from your subclass init.

def get_header(self, section, atom)
    Called during parsing when input format contains header (__WITH_HEADER__ is
    set to True). This function should try to find and parse header in a given
    sub_section and save results as a dictionary to atom['header']. If parsing
    was successfull it should return True and False otherwise. Note that though
    programmer is not required to follow any naming convention, it is HIGHLY
    RECOMMENDED to name atom['header'] keys with full, lower case, underscore
    separated names (like 'information', 'delay', 'author', 'version', 'title'
    etc.). It is to allow sharing those pieces of informations between various
    formats.
    For formats with __WITH_HEADER__ set to True this method is checked until it
    returns True (or __MAX_HEADER_LEN__ is reached).

def convert_header(self, header)
    Convert given header (which is dictionary saved by input class get_header
    method) to string. Note that it is HIGHLY RECOMMENDED to define default
    values for all required pieces of informations as formats does not have to
    share some informations between each other.

def format_text(self, s)
    This one is called by parse() method to convert sub-type specific formatting
    to the one recognised by GenericSubParser. Specific to sub format formatting
    strings should be changed to tags described in sub_formatting constant. It
    can be done any way you prefer (regex, string manipulation, ...).
    Important note: don't forget to escape any curly braces ('{' and '}') that
    may occur in sub text as they might break things down.

def str_to_frametime(self, s)
    Convert strings got by time_pattern regex to FrameTime objects. It is
    important to have common time format which can be passed, recognised and
    operated on by various GenericSubParser subclasses (subtitle formats).

def get_time(self, ft, which)
    Extract time (time_from or time_to) from FrameTime (which is passed in
    yielding by parse() method dictionary). Note that it usually needs to be
    first calculated using 'to_frame or to_time methods. The output is properly
    formatted string according to subtitle specification. There is also a
    possibility to specify different formats for 'time_from' and 'time_to' which
    can be differ thanks to 'which' argument.

Note that if you feel ok with defaults of all above constants attributes, you
don't have to even touch them. Read the code for more info!

[ 3 License ]
Subconvert is free software licensed under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
For details, see <LICENSE.txt> or http://www.gnu.org/licenses/gpl.html
